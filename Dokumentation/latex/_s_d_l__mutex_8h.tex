\section{C\+:/\+Users/\+Max/\+Documents/\+Git\+Hub/\+Ballerburg/\+Ballerburg\+\_\+v001/\+Resources/\+S\+D\+L-\/1.2.15/include/\+S\+D\+L/\+S\+D\+L\+\_\+mutex.h File Reference}
\label{_s_d_l__mutex_8h}\index{C\+:/\+Users/\+Max/\+Documents/\+Git\+Hub/\+Ballerburg/\+Ballerburg\+\_\+v001/\+Resources/\+S\+D\+L-\/1.\+2.\+15/include/\+S\+D\+L/\+S\+D\+L\+\_\+mutex.\+h@{C\+:/\+Users/\+Max/\+Documents/\+Git\+Hub/\+Ballerburg/\+Ballerburg\+\_\+v001/\+Resources/\+S\+D\+L-\/1.\+2.\+15/include/\+S\+D\+L/\+S\+D\+L\+\_\+mutex.\+h}}


Functions to provide thread synchronization primitives.  


{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+stdinc.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+error.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\\*
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bf S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+U\+T}~1\label{_s_d_l__mutex_8h_a1214610634c24465d7c50149752791a9}

\begin{DoxyCompactList}\small\item\em Synchronization functions which can time out return this value if they time out. \end{DoxyCompactList}\item 
\#define {\bf S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+M\+A\+X\+W\+A\+I\+T}~($\sim$(Uint32)0)\label{_s_d_l__mutex_8h_abd2bc8605242c50341362ada961dc914}

\begin{DoxyCompactList}\small\item\em This is the timeout value which corresponds to never time out. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{Indent}{\bf Condition\+\_\+variable\+\_\+functions}\par
\begin{DoxyCompactItemize}
\item 
typedef struct S\+D\+L\+\_\+cond {\bfseries S\+D\+L\+\_\+cond}\label{_s_d_l__mutex_8h_ac50401d1b84d806a0c927c8cf454f96a}

\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} S\+D\+L\+\_\+cond $\ast${\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Create\+Cond} (void)\label{_s_d_l__mutex_8h_ac729fb4dbfe4057452ebfc1087f61585}

\begin{DoxyCompactList}\small\item\em Create a condition variable. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Destroy\+Cond} (S\+D\+L\+\_\+cond $\ast$cond)\label{_s_d_l__mutex_8h_a8843feeb270845e07fc23f692707540f}

\begin{DoxyCompactList}\small\item\em Destroy a condition variable. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Cond\+Signal} (S\+D\+L\+\_\+cond $\ast$cond)
\begin{DoxyCompactList}\small\item\em Restart one of the threads that are waiting on the condition variable,. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Cond\+Broadcast} (S\+D\+L\+\_\+cond $\ast$cond)
\begin{DoxyCompactList}\small\item\em Restart all threads that are waiting on the condition variable,. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Cond\+Wait} (S\+D\+L\+\_\+cond $\ast$cond, S\+D\+L\+\_\+mutex $\ast$mut)
\begin{DoxyCompactList}\small\item\em Wait on the condition variable, unlocking the provided mutex. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Cond\+Wait\+Timeout} (S\+D\+L\+\_\+cond $\ast$cond, S\+D\+L\+\_\+mutex $\ast$mutex, Uint32 ms)
\begin{DoxyCompactList}\small\item\em Waits for at most \textquotesingle{}ms\textquotesingle{} milliseconds, and returns 0 if the condition variable is signaled, S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+U\+T if the condition is not signaled in the allotted time, and -\/1 on error. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Mutex functions}
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries S\+D\+L\+\_\+\+Lock\+Mutex}(m)~{\bf S\+D\+L\+\_\+mutex\+P}(m)\label{_s_d_l__mutex_8h_a64777a2ee0f044c2634486905480734e}

\item 
\#define {\bfseries S\+D\+L\+\_\+\+Unlock\+Mutex}(m)~{\bf S\+D\+L\+\_\+mutex\+V}(m)\label{_s_d_l__mutex_8h_a86556b4c963b45fa5a6b909e3eef8489}

\item 
typedef struct S\+D\+L\+\_\+mutex {\bfseries S\+D\+L\+\_\+mutex}\label{_s_d_l__mutex_8h_ac085162a7cfb9ebd63e2d05d33c03c17}

\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} S\+D\+L\+\_\+mutex $\ast${\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Create\+Mutex} (void)\label{_s_d_l__mutex_8h_ae1f90ad6a7420fb3c4b5685e440d762f}

\begin{DoxyCompactList}\small\item\em Create a mutex, initialized unlocked. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+mutex\+P} (S\+D\+L\+\_\+mutex $\ast$mutex)
\begin{DoxyCompactList}\small\item\em Lock the mutex. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+mutex\+V} (S\+D\+L\+\_\+mutex $\ast$mutex)
\begin{DoxyCompactList}\small\item\em Unlock the mutex. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Destroy\+Mutex} (S\+D\+L\+\_\+mutex $\ast$mutex)\label{_s_d_l__mutex_8h_ad2bbcc4e32ac927af62f0cba671f63fe}

\begin{DoxyCompactList}\small\item\em Destroy a mutex. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Semaphore functions}
\begin{DoxyCompactItemize}
\item 
typedef struct S\+D\+L\+\_\+semaphore {\bfseries S\+D\+L\+\_\+sem}\label{_s_d_l__mutex_8h_aa7d56df841e98eed229d1d4b17327d29}

\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} S\+D\+L\+\_\+sem $\ast${\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Create\+Semaphore} (Uint32 initial\+\_\+value)
\begin{DoxyCompactList}\small\item\em Create a semaphore, initialized with value, returns N\+U\+L\+L on failure. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Destroy\+Semaphore} (S\+D\+L\+\_\+sem $\ast$sem)\label{_s_d_l__mutex_8h_a23deb3b7e29a5137d804e4be3453a768}

\begin{DoxyCompactList}\small\item\em Destroy a semaphore. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Sem\+Wait} (S\+D\+L\+\_\+sem $\ast$sem)
\begin{DoxyCompactList}\small\item\em This function suspends the calling thread until the semaphore pointed to by sem has a positive count. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Sem\+Try\+Wait} (S\+D\+L\+\_\+sem $\ast$sem)
\begin{DoxyCompactList}\small\item\em Non-\/blocking variant of \doxyref{S\+D\+L\+\_\+\+Sem\+Wait()}{p.}{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Sem\+Wait\+Timeout} (S\+D\+L\+\_\+sem $\ast$sem, Uint32 ms)
\begin{DoxyCompactList}\small\item\em Variant of \doxyref{S\+D\+L\+\_\+\+Sem\+Wait()}{p.}{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792} with a timeout in milliseconds, returns 0 if the wait succeeds, S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+U\+T if the wait does not succeed in the allotted time, and -\/1 on error. \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Sem\+Post} (S\+D\+L\+\_\+sem $\ast$sem)
\begin{DoxyCompactList}\small\item\em Atomically increases the semaphore\textquotesingle{}s count (not blocking). \end{DoxyCompactList}\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} Uint32 {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Sem\+Value} (S\+D\+L\+\_\+sem $\ast$sem)\label{_s_d_l__mutex_8h_ae66390dca585fdab8de871fe32935768}

\begin{DoxyCompactList}\small\item\em Returns the current count of the semaphore. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
Functions to provide thread synchronization primitives. 

\begin{DoxyNote}{Note}
These are independent of the other S\+D\+L routines. 
\end{DoxyNote}


\subsection{Function Documentation}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Cond\+Broadcast@{S\+D\+L\+\_\+\+Cond\+Broadcast}}
\index{S\+D\+L\+\_\+\+Cond\+Broadcast@{S\+D\+L\+\_\+\+Cond\+Broadcast}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Cond\+Broadcast}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Cond\+Broadcast (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+cond $\ast$}]{cond}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a2ffd0b45ebdc44057007a59857ba46b3}


Restart all threads that are waiting on the condition variable,. 

\begin{DoxyReturn}{Returns}
0 or -\/1 on error. 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Cond\+Signal@{S\+D\+L\+\_\+\+Cond\+Signal}}
\index{S\+D\+L\+\_\+\+Cond\+Signal@{S\+D\+L\+\_\+\+Cond\+Signal}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Cond\+Signal}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Cond\+Signal (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+cond $\ast$}]{cond}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a1037a8274b0b13118fc78eeb417a1397}


Restart one of the threads that are waiting on the condition variable,. 

\begin{DoxyReturn}{Returns}
0 or -\/1 on error. 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Cond\+Wait@{S\+D\+L\+\_\+\+Cond\+Wait}}
\index{S\+D\+L\+\_\+\+Cond\+Wait@{S\+D\+L\+\_\+\+Cond\+Wait}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Cond\+Wait}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Cond\+Wait (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+cond $\ast$}]{cond, }
\item[{S\+D\+L\+\_\+mutex $\ast$}]{mut}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a61914b63bc3462ad99bc543ad7b935ac}


Wait on the condition variable, unlocking the provided mutex. 

The mutex must be locked before entering this function! The mutex is re-\/locked once the condition variable is signaled. \begin{DoxyReturn}{Returns}
0 when it is signaled, or -\/1 on error. 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Cond\+Wait\+Timeout@{S\+D\+L\+\_\+\+Cond\+Wait\+Timeout}}
\index{S\+D\+L\+\_\+\+Cond\+Wait\+Timeout@{S\+D\+L\+\_\+\+Cond\+Wait\+Timeout}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Cond\+Wait\+Timeout}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Cond\+Wait\+Timeout (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+cond $\ast$}]{cond, }
\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex, }
\item[{Uint32}]{ms}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_aa57013f95a9c608cf24a5100b841e863}


Waits for at most \textquotesingle{}ms\textquotesingle{} milliseconds, and returns 0 if the condition variable is signaled, S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+U\+T if the condition is not signaled in the allotted time, and -\/1 on error. 

On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. \index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Create\+Semaphore@{S\+D\+L\+\_\+\+Create\+Semaphore}}
\index{S\+D\+L\+\_\+\+Create\+Semaphore@{S\+D\+L\+\_\+\+Create\+Semaphore}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Create\+Semaphore}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} S\+D\+L\+\_\+sem$\ast$ {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Create\+Semaphore (
\begin{DoxyParamCaption}
\item[{Uint32}]{initial\+\_\+value}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_ab8c1a20a5466281a5d63a0cabe07e140}


Create a semaphore, initialized with value, returns N\+U\+L\+L on failure. 

\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+mutex\+P@{S\+D\+L\+\_\+mutex\+P}}
\index{S\+D\+L\+\_\+mutex\+P@{S\+D\+L\+\_\+mutex\+P}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+mutex\+P}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+mutex\+P (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_adf4b3afa562b1277fdc53d262e2c236b}


Lock the mutex. 

\begin{DoxyReturn}{Returns}
0, or -\/1 on error 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+mutex\+V@{S\+D\+L\+\_\+mutex\+V}}
\index{S\+D\+L\+\_\+mutex\+V@{S\+D\+L\+\_\+mutex\+V}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+mutex\+V}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+mutex\+V (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+mutex $\ast$}]{mutex}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a606b7f1600caba3cfcbe096873539515}


Unlock the mutex. 

\begin{DoxyReturn}{Returns}
0, or -\/1 on error
\end{DoxyReturn}
It is an error to unlock a mutex that has not been locked by the current thread, and doing so results in undefined behavior. \index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Sem\+Post@{S\+D\+L\+\_\+\+Sem\+Post}}
\index{S\+D\+L\+\_\+\+Sem\+Post@{S\+D\+L\+\_\+\+Sem\+Post}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Sem\+Post}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Sem\+Post (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+sem $\ast$}]{sem}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a0c50f774babf7a44c381238a1f780595}


Atomically increases the semaphore\textquotesingle{}s count (not blocking). 

\begin{DoxyReturn}{Returns}
0, or -\/1 on error. 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Sem\+Try\+Wait@{S\+D\+L\+\_\+\+Sem\+Try\+Wait}}
\index{S\+D\+L\+\_\+\+Sem\+Try\+Wait@{S\+D\+L\+\_\+\+Sem\+Try\+Wait}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Sem\+Try\+Wait}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Sem\+Try\+Wait (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+sem $\ast$}]{sem}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a517288aaa856ce2264e8420636e85c4a}


Non-\/blocking variant of \doxyref{S\+D\+L\+\_\+\+Sem\+Wait()}{p.}{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}. 

\begin{DoxyReturn}{Returns}
0 if the wait succeeds, S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+U\+T if the wait would block, and -\/1 on error. 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Sem\+Wait@{S\+D\+L\+\_\+\+Sem\+Wait}}
\index{S\+D\+L\+\_\+\+Sem\+Wait@{S\+D\+L\+\_\+\+Sem\+Wait}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Sem\+Wait}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Sem\+Wait (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+sem $\ast$}]{sem}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792}


This function suspends the calling thread until the semaphore pointed to by sem has a positive count. 

It then atomically decreases the semaphore count. \index{S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}!S\+D\+L\+\_\+\+Sem\+Wait\+Timeout@{S\+D\+L\+\_\+\+Sem\+Wait\+Timeout}}
\index{S\+D\+L\+\_\+\+Sem\+Wait\+Timeout@{S\+D\+L\+\_\+\+Sem\+Wait\+Timeout}!S\+D\+L\+\_\+mutex.\+h@{S\+D\+L\+\_\+mutex.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Sem\+Wait\+Timeout}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Sem\+Wait\+Timeout (
\begin{DoxyParamCaption}
\item[{S\+D\+L\+\_\+sem $\ast$}]{sem, }
\item[{Uint32}]{ms}
\end{DoxyParamCaption}
)}\label{_s_d_l__mutex_8h_a4ea1acfaf722895626174e1e37c497da}


Variant of \doxyref{S\+D\+L\+\_\+\+Sem\+Wait()}{p.}{_s_d_l__mutex_8h_af51d75d18cb90f28b35c31e853b04792} with a timeout in milliseconds, returns 0 if the wait succeeds, S\+D\+L\+\_\+\+M\+U\+T\+E\+X\+\_\+\+T\+I\+M\+E\+D\+O\+U\+T if the wait does not succeed in the allotted time, and -\/1 on error. 

On some platforms this function is implemented by looping with a delay of 1 ms, and so should be avoided if possible. 