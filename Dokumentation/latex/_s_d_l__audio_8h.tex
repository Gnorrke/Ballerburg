\section{C\+:/\+Users/\+Max/\+Documents/\+Git\+Hub/\+Ballerburg/\+Ballerburg\+\_\+v001/\+Resources/\+S\+D\+L-\/1.2.15/include/\+S\+D\+L/\+S\+D\+L\+\_\+audio.h File Reference}
\label{_s_d_l__audio_8h}\index{C\+:/\+Users/\+Max/\+Documents/\+Git\+Hub/\+Ballerburg/\+Ballerburg\+\_\+v001/\+Resources/\+S\+D\+L-\/1.\+2.\+15/include/\+S\+D\+L/\+S\+D\+L\+\_\+audio.\+h@{C\+:/\+Users/\+Max/\+Documents/\+Git\+Hub/\+Ballerburg/\+Ballerburg\+\_\+v001/\+Resources/\+S\+D\+L-\/1.\+2.\+15/include/\+S\+D\+L/\+S\+D\+L\+\_\+audio.\+h}}
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+stdinc.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+error.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+endian.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+mutex.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+thread.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}S\+D\+L\+\_\+rwops.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}begin\+\_\+code.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}close\+\_\+code.\+h\char`\"{}}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf S\+D\+L\+\_\+\+Audio\+Spec}
\item 
struct {\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T}
\end{DoxyCompactItemize}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define {\bf S\+D\+L\+\_\+\+Load\+W\+A\+V}(file,  spec,  audio\+\_\+buf,  audio\+\_\+len)~{\bf S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W}(S\+D\+L\+\_\+\+R\+W\+From\+File(file, \char`\"{}rb\char`\"{}),1, spec,audio\+\_\+buf,audio\+\_\+len)
\item 
\#define {\bfseries S\+D\+L\+\_\+\+M\+I\+X\+\_\+\+M\+A\+X\+V\+O\+L\+U\+M\+E}~128\label{_s_d_l__audio_8h_afa8e5e92d4424b0c599e7c813c91f720}

\end{DoxyCompactItemize}
\begin{Indent}{\bf Audio format flags}\par
{\em defaults to L\+S\+B byte order }\begin{DoxyCompactItemize}
\item 
\#define {\bf A\+U\+D\+I\+O\+\_\+\+U8}~0x0008
\item 
\#define {\bf A\+U\+D\+I\+O\+\_\+\+S8}~0x8008
\item 
\#define {\bf A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B}~0x0010
\item 
\#define {\bf A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B}~0x8010
\item 
\#define {\bf A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B}~0x1010
\item 
\#define {\bf A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B}~0x9010
\item 
\#define {\bfseries A\+U\+D\+I\+O\+\_\+\+U16}~{\bf A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B}\label{_s_d_l__audio_8h_adee2cdf7dbda44620da17cd58ca819ea}

\item 
\#define {\bfseries A\+U\+D\+I\+O\+\_\+\+S16}~{\bf A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B}\label{_s_d_l__audio_8h_a4f4950d8eee757ebed84e50fb9316b12}

\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Native audio byte ordering}\par
\begin{DoxyCompactItemize}
\item 
\#define {\bfseries A\+U\+D\+I\+O\+\_\+\+U16\+S\+Y\+S}~{\bf A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B}\label{_s_d_l__audio_8h_afafc9f93ee2c583130c4152e243ba5b8}

\item 
\#define {\bfseries A\+U\+D\+I\+O\+\_\+\+S16\+S\+Y\+S}~{\bf A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B}\label{_s_d_l__audio_8h_a4722de7e16982dd078f2b8cc64b9bae7}

\end{DoxyCompactItemize}
\end{Indent}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef struct {\bf S\+D\+L\+\_\+\+Audio\+Spec} {\bf S\+D\+L\+\_\+\+Audio\+Spec}
\item 
typedef struct {\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T} {\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T}
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bfseries S\+D\+L\+\_\+audiostatus} \{ {\bfseries S\+D\+L\+\_\+\+A\+U\+D\+I\+O\+\_\+\+S\+T\+O\+P\+P\+E\+D} = 0, 
{\bfseries S\+D\+L\+\_\+\+A\+U\+D\+I\+O\+\_\+\+P\+L\+A\+Y\+I\+N\+G}, 
{\bfseries S\+D\+L\+\_\+\+A\+U\+D\+I\+O\+\_\+\+P\+A\+U\+S\+E\+D}
 \}\label{_s_d_l__audio_8h_ae67ea72fc0b72d474bdaaf42b1dd9361}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} char $\ast${\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Audio\+Driver\+Name} (char $\ast$namebuf, int maxlen)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Open\+Audio} ({\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast$desired, {\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast$obtained)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} S\+D\+L\+\_\+audiostatus {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Get\+Audio\+Status} (void)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Pause\+Audio} (int pause\+\_\+on)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} {\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast${\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W} ({\bf S\+D\+L\+\_\+\+R\+Wops} $\ast$src, int freesrc, {\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast$spec, Uint8 $\ast$$\ast$audio\+\_\+buf, Uint32 $\ast$audio\+\_\+len)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Free\+W\+A\+V} (Uint8 $\ast$audio\+\_\+buf)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T} ({\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T} $\ast$cvt, Uint16 src\+\_\+format, Uint8 src\+\_\+channels, int src\+\_\+rate, Uint16 dst\+\_\+format, Uint8 dst\+\_\+channels, int dst\+\_\+rate)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Convert\+Audio} ({\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T} $\ast$cvt)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Mix\+Audio} (Uint8 $\ast$dst, const Uint8 $\ast$src, Uint32 len, int volume)
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bf S\+D\+L\+\_\+\+Close\+Audio} (void)
\end{DoxyCompactItemize}
\begin{Indent}{\bf Audio Init and Quit}\par
{\em These functions are used internally, and should not be used unless you have a specific need to specify the audio driver you want to use. You should normally use \doxyref{S\+D\+L\+\_\+\+Init()}{p.}{_s_d_l_8h_a8fc8d35348d7c74bad8392d776c937b8} or \doxyref{S\+D\+L\+\_\+\+Init\+Sub\+System()}{p.}{_s_d_l_8h_adfbfddc0ec609b5e5e5cb1c89298e4db}. }\begin{DoxyCompactItemize}
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} {\bfseries S\+D\+L\+\_\+\+Audio\+Init} (const char $\ast$driver\+\_\+name)\label{_s_d_l__audio_8h_ae3667d6ba706a3ca7affd8611632fa2c}

\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bfseries S\+D\+L\+\_\+\+Audio\+Quit} (void)\label{_s_d_l__audio_8h_a478c602cbfaab8663cb4f58a62600323}

\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}{\bf Audio Locks}\par
{\em The lock manipulated by these functions protects the callback function. During a Lock\+Audio/\+Unlock\+Audio pair, you can be guaranteed that the callback function is not running. Do not call these from the callback function or you will cause deadlock. }\begin{DoxyCompactItemize}
\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bfseries S\+D\+L\+\_\+\+Lock\+Audio} (void)\label{_s_d_l__audio_8h_a7ffa484f230f6085e271a4f43e678f06}

\item 
{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} {\bfseries S\+D\+L\+\_\+\+Unlock\+Audio} (void)\label{_s_d_l__audio_8h_a76d8179bee14dad268e65378058d897d}

\end{DoxyCompactItemize}
\end{Indent}


\subsection{Detailed Description}
Access to the raw audio mixing buffer for the S\+D\+L library 

\subsection{Macro Definition Documentation}
\index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B@{A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B}}
\index{A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B@{A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+U\+D\+I\+O\+\_\+\+S16\+L\+S\+B~0x8010}\label{_s_d_l__audio_8h_a23838d612e88ce72d82c3e51460f831b}
Signed 16-\/bit samples \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B@{A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B}}
\index{A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B@{A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+U\+D\+I\+O\+\_\+\+S16\+M\+S\+B~0x9010}\label{_s_d_l__audio_8h_a3109dfb1d7aab29dff2b62d630e690ca}
As above, but big-\/endian byte order \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!A\+U\+D\+I\+O\+\_\+\+S8@{A\+U\+D\+I\+O\+\_\+\+S8}}
\index{A\+U\+D\+I\+O\+\_\+\+S8@{A\+U\+D\+I\+O\+\_\+\+S8}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{A\+U\+D\+I\+O\+\_\+\+S8}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+U\+D\+I\+O\+\_\+\+S8~0x8008}\label{_s_d_l__audio_8h_a883b3d4539451e49bf014dde0f9cca29}
Signed 8-\/bit samples \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B@{A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B}}
\index{A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B@{A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+U\+D\+I\+O\+\_\+\+U16\+L\+S\+B~0x0010}\label{_s_d_l__audio_8h_a06808f806896c4d211314990c354b7fc}
Unsigned 16-\/bit samples \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B@{A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B}}
\index{A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B@{A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+U\+D\+I\+O\+\_\+\+U16\+M\+S\+B~0x1010}\label{_s_d_l__audio_8h_a3b8052d0c49d14a2e3edf08eade52d3a}
As above, but big-\/endian byte order \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!A\+U\+D\+I\+O\+\_\+\+U8@{A\+U\+D\+I\+O\+\_\+\+U8}}
\index{A\+U\+D\+I\+O\+\_\+\+U8@{A\+U\+D\+I\+O\+\_\+\+U8}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{A\+U\+D\+I\+O\+\_\+\+U8}]{\setlength{\rightskip}{0pt plus 5cm}\#define A\+U\+D\+I\+O\+\_\+\+U8~0x0008}\label{_s_d_l__audio_8h_a6468b4b3fc53ada655eca866e491d75f}
Unsigned 8-\/bit samples \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Load\+W\+A\+V@{S\+D\+L\+\_\+\+Load\+W\+A\+V}}
\index{S\+D\+L\+\_\+\+Load\+W\+A\+V@{S\+D\+L\+\_\+\+Load\+W\+A\+V}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Load\+W\+A\+V}]{\setlength{\rightskip}{0pt plus 5cm}\#define S\+D\+L\+\_\+\+Load\+W\+A\+V(
\begin{DoxyParamCaption}
\item[{}]{file, }
\item[{}]{spec, }
\item[{}]{audio\+\_\+buf, }
\item[{}]{audio\+\_\+len}
\end{DoxyParamCaption}
)~{\bf S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W}(S\+D\+L\+\_\+\+R\+W\+From\+File(file, \char`\"{}rb\char`\"{}),1, spec,audio\+\_\+buf,audio\+\_\+len)}\label{_s_d_l__audio_8h_a611f76dc30ba9891239bcce3f9b472b5}
Compatibility convenience function -- loads a W\+A\+V from a file 

\subsection{Typedef Documentation}
\index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Audio\+C\+V\+T@{S\+D\+L\+\_\+\+Audio\+C\+V\+T}}
\index{S\+D\+L\+\_\+\+Audio\+C\+V\+T@{S\+D\+L\+\_\+\+Audio\+C\+V\+T}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Audio\+C\+V\+T}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T}  {\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T}}\label{_s_d_l__audio_8h_acddd16bc3257a83299e7abe6d160ba0a}
A structure to hold a set of audio conversion filters and buffers \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Audio\+Spec@{S\+D\+L\+\_\+\+Audio\+Spec}}
\index{S\+D\+L\+\_\+\+Audio\+Spec@{S\+D\+L\+\_\+\+Audio\+Spec}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Audio\+Spec}]{\setlength{\rightskip}{0pt plus 5cm}typedef struct {\bf S\+D\+L\+\_\+\+Audio\+Spec}  {\bf S\+D\+L\+\_\+\+Audio\+Spec}}\label{_s_d_l__audio_8h_a77faa7fe3d22c03ee61466a901c22a25}
When filling in the desired audio spec structure,
\begin{DoxyItemize}
\item \textquotesingle{}desired-\/$>$freq\textquotesingle{} should be the desired audio frequency in samples-\/per-\/second.
\item \textquotesingle{}desired-\/$>$format\textquotesingle{} should be the desired audio format.
\item \textquotesingle{}desired-\/$>$samples\textquotesingle{} is the desired size of the audio buffer, in samples. This number should be a power of two, and may be adjusted by the audio driver to a value more suitable for the hardware. Good values seem to range between 512 and 8096 inclusive, depending on the application and C\+P\+U speed. Smaller values yield faster response time, but can lead to underflow if the application is doing heavy processing and cannot fill the audio buffer in time. A stereo sample consists of both right and left channels in L\+R ordering. Note that the number of samples is directly related to time by the following formula\+: ms = (samples$\ast$1000)/freq
\item \textquotesingle{}desired-\/$>$size\textquotesingle{} is the size in bytes of the audio buffer, and is calculated by \doxyref{S\+D\+L\+\_\+\+Open\+Audio()}{p.}{_s_d_l__audio_8h_a2edf30e7747584e28041b4986f89f440}.
\item \textquotesingle{}desired-\/$>$silence\textquotesingle{} is the value used to set the buffer to silence, and is calculated by \doxyref{S\+D\+L\+\_\+\+Open\+Audio()}{p.}{_s_d_l__audio_8h_a2edf30e7747584e28041b4986f89f440}.
\item \textquotesingle{}desired-\/$>$callback\textquotesingle{} should be set to a function that will be called when the audio device is ready for more data. It is passed a pointer to the audio buffer, and the length in bytes of the audio buffer. This function usually runs in a separate thread, and so you should protect data structures that it accesses by calling S\+D\+L\+\_\+\+Lock\+Audio() and S\+D\+L\+\_\+\+Unlock\+Audio() in your code.
\item \textquotesingle{}desired-\/$>$userdata\textquotesingle{} is passed as the first parameter to your callback function.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
The calculated values in this structure are calculated by \doxyref{S\+D\+L\+\_\+\+Open\+Audio()}{p.}{_s_d_l__audio_8h_a2edf30e7747584e28041b4986f89f440} 
\end{DoxyNote}


\subsection{Function Documentation}
\index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Audio\+Driver\+Name@{S\+D\+L\+\_\+\+Audio\+Driver\+Name}}
\index{S\+D\+L\+\_\+\+Audio\+Driver\+Name@{S\+D\+L\+\_\+\+Audio\+Driver\+Name}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Audio\+Driver\+Name}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} char$\ast$ {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Audio\+Driver\+Name (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{namebuf, }
\item[{int}]{maxlen}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_a1e676f8703a36ade7e3524eadfdc5dd0}
This function fills the given character buffer with the name of the current audio driver, and returns a pointer to it if the audio driver has been initialized. It returns N\+U\+L\+L if no driver has been initialized. \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T@{S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T}}
\index{S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T@{S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T (
\begin{DoxyParamCaption}
\item[{{\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T} $\ast$}]{cvt, }
\item[{Uint16}]{src\+\_\+format, }
\item[{Uint8}]{src\+\_\+channels, }
\item[{int}]{src\+\_\+rate, }
\item[{Uint16}]{dst\+\_\+format, }
\item[{Uint8}]{dst\+\_\+channels, }
\item[{int}]{dst\+\_\+rate}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_ab89d6be44de5fbe6d06fe59e05975e68}
This function takes a source format and rate and a destination format and rate, and initializes the \textquotesingle{}cvt\textquotesingle{} structure with information needed by \doxyref{S\+D\+L\+\_\+\+Convert\+Audio()}{p.}{_s_d_l__audio_8h_a8e8660222356e07002dde4928118b7df} to convert a buffer of audio data from one format to the other.

\begin{DoxyReturn}{Returns}
This function returns 0, or -\/1 if there was an error. 
\end{DoxyReturn}
\index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Close\+Audio@{S\+D\+L\+\_\+\+Close\+Audio}}
\index{S\+D\+L\+\_\+\+Close\+Audio@{S\+D\+L\+\_\+\+Close\+Audio}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Close\+Audio}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Close\+Audio (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_aa176acc650e66e1d38814cbed3ca258e}
This function shuts down audio processing and closes the audio device. \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Convert\+Audio@{S\+D\+L\+\_\+\+Convert\+Audio}}
\index{S\+D\+L\+\_\+\+Convert\+Audio@{S\+D\+L\+\_\+\+Convert\+Audio}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Convert\+Audio}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Convert\+Audio (
\begin{DoxyParamCaption}
\item[{{\bf S\+D\+L\+\_\+\+Audio\+C\+V\+T} $\ast$}]{cvt}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_a8e8660222356e07002dde4928118b7df}
Once you have initialized the \textquotesingle{}cvt\textquotesingle{} structure using \doxyref{S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T()}{p.}{_s_d_l__audio_8h_ab89d6be44de5fbe6d06fe59e05975e68}, created an audio buffer cvt-\/$>$buf, and filled it with cvt-\/$>$len bytes of audio data in the source format, this function will convert it in-\/place to the desired format. The data conversion may expand the size of the audio data, so the buffer cvt-\/$>$buf should be allocated after the cvt structure is initialized by \doxyref{S\+D\+L\+\_\+\+Build\+Audio\+C\+V\+T()}{p.}{_s_d_l__audio_8h_ab89d6be44de5fbe6d06fe59e05975e68}, and should be cvt-\/$>$len$\ast$cvt-\/$>$len\+\_\+mult bytes long. \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Free\+W\+A\+V@{S\+D\+L\+\_\+\+Free\+W\+A\+V}}
\index{S\+D\+L\+\_\+\+Free\+W\+A\+V@{S\+D\+L\+\_\+\+Free\+W\+A\+V}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Free\+W\+A\+V}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Free\+W\+A\+V (
\begin{DoxyParamCaption}
\item[{Uint8 $\ast$}]{audio\+\_\+buf}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_a631aa8624575603df2c5ab9257feee59}
This function frees data previously allocated with \doxyref{S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W()}{p.}{_s_d_l__audio_8h_a7e5d38e8c1f8951704a76330c3b1ac81} \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Get\+Audio\+Status@{S\+D\+L\+\_\+\+Get\+Audio\+Status}}
\index{S\+D\+L\+\_\+\+Get\+Audio\+Status@{S\+D\+L\+\_\+\+Get\+Audio\+Status}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Get\+Audio\+Status}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} S\+D\+L\+\_\+audiostatus {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Get\+Audio\+Status (
\begin{DoxyParamCaption}
\item[{void}]{}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_a43b2a088225e6b1bf0c9feef4a9df918}
Get the current audio state \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W@{S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W}}
\index{S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W@{S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} {\bf S\+D\+L\+\_\+\+Audio\+Spec}$\ast$ {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Load\+W\+A\+V\+\_\+\+R\+W (
\begin{DoxyParamCaption}
\item[{{\bf S\+D\+L\+\_\+\+R\+Wops} $\ast$}]{src, }
\item[{int}]{freesrc, }
\item[{{\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast$}]{spec, }
\item[{Uint8 $\ast$$\ast$}]{audio\+\_\+buf, }
\item[{Uint32 $\ast$}]{audio\+\_\+len}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_a7e5d38e8c1f8951704a76330c3b1ac81}
This function loads a W\+A\+V\+E from the data source, automatically freeing that source if \textquotesingle{}freesrc\textquotesingle{} is non-\/zero. For example, to load a W\+A\+V\+E file, you could do\+: 
\begin{DoxyCode}
1 SDL\_LoadWAV\_RW(SDL\_RWFromFile("sample.wav", "rb"), 1, ...); 
\end{DoxyCode}


If this function succeeds, it returns the given \doxyref{S\+D\+L\+\_\+\+Audio\+Spec}{p.}{struct_s_d_l___audio_spec}, filled with the audio data format of the wave data, and sets \textquotesingle{}audio\+\_\+buf\textquotesingle{} to a malloc()\textquotesingle{}d buffer containing the audio data, and sets \textquotesingle{}audio\+\_\+len\textquotesingle{} to the length of that audio buffer, in bytes. You need to free the audio buffer with \doxyref{S\+D\+L\+\_\+\+Free\+W\+A\+V()}{p.}{_s_d_l__audio_8h_a631aa8624575603df2c5ab9257feee59} when you are done with it.

This function returns N\+U\+L\+L and sets the S\+D\+L error message if the wave file cannot be opened, uses an unknown data format, or is corrupt. Currently raw and M\+S-\/\+A\+D\+P\+C\+M W\+A\+V\+E files are supported. \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Mix\+Audio@{S\+D\+L\+\_\+\+Mix\+Audio}}
\index{S\+D\+L\+\_\+\+Mix\+Audio@{S\+D\+L\+\_\+\+Mix\+Audio}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Mix\+Audio}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Mix\+Audio (
\begin{DoxyParamCaption}
\item[{Uint8 $\ast$}]{dst, }
\item[{const Uint8 $\ast$}]{src, }
\item[{Uint32}]{len, }
\item[{int}]{volume}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_ab9ad945b4b15d816802f5a79da06c9f9}
This takes two audio buffers of the playing audio format and mixes them, performing addition, volume adjustment, and overflow clipping. The volume ranges from 0 -\/ 128, and should be set to S\+D\+L\+\_\+\+M\+I\+X\+\_\+\+M\+A\+X\+V\+O\+L\+U\+M\+E for full audio volume. Note this does not change hardware volume. This is provided for convenience -- you can mix your own audio data. \index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Open\+Audio@{S\+D\+L\+\_\+\+Open\+Audio}}
\index{S\+D\+L\+\_\+\+Open\+Audio@{S\+D\+L\+\_\+\+Open\+Audio}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Open\+Audio}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} int {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Open\+Audio (
\begin{DoxyParamCaption}
\item[{{\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast$}]{desired, }
\item[{{\bf S\+D\+L\+\_\+\+Audio\+Spec} $\ast$}]{obtained}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_a2edf30e7747584e28041b4986f89f440}
This function opens the audio device with the desired parameters, and returns 0 if successful, placing the actual hardware parameters in the structure pointed to by \textquotesingle{}obtained\textquotesingle{}. If \textquotesingle{}obtained\textquotesingle{} is N\+U\+L\+L, the audio data passed to the callback function will be guaranteed to be in the requested format, and will be automatically converted to the hardware audio format if necessary. This function returns -\/1 if it failed to open the audio device, or couldn\textquotesingle{}t set up the audio thread.

The audio device starts out playing silence when it\textquotesingle{}s opened, and should be enabled for playing by calling S\+D\+L\+\_\+\+Pause\+Audio(0) when you are ready for your audio callback function to be called. Since the audio driver may modify the requested size of the audio buffer, you should allocate any local mixing buffers after you open the audio device.

\begin{DoxySeeAlso}{See also}
\doxyref{S\+D\+L\+\_\+\+Audio\+Spec}{p.}{struct_s_d_l___audio_spec} 
\end{DoxySeeAlso}
\index{S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}!S\+D\+L\+\_\+\+Pause\+Audio@{S\+D\+L\+\_\+\+Pause\+Audio}}
\index{S\+D\+L\+\_\+\+Pause\+Audio@{S\+D\+L\+\_\+\+Pause\+Audio}!S\+D\+L\+\_\+audio.\+h@{S\+D\+L\+\_\+audio.\+h}}
\subsubsection[{S\+D\+L\+\_\+\+Pause\+Audio}]{\setlength{\rightskip}{0pt plus 5cm}{\bf D\+E\+C\+L\+S\+P\+E\+C} void {\bf S\+D\+L\+C\+A\+L\+L} S\+D\+L\+\_\+\+Pause\+Audio (
\begin{DoxyParamCaption}
\item[{int}]{pause\+\_\+on}
\end{DoxyParamCaption}
)}\label{_s_d_l__audio_8h_aa68e60a33666ff4f2d36f3827b1d6061}
This function pauses and unpauses the audio callback processing. It should be called with a parameter of 0 after opening the audio device to start playing sound. This is so you can safely initialize data for your callback function after opening the audio device. Silence will be written to the audio device during the pause. 